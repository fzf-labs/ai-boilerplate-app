---
name: tech-decision
description: 技术选型决策技能。当用户需要进行技术选型、技术对比、架构决策时使用此技能。触发场景包括：(1) 选择技术框架/库 (2) 对比技术方案 (3) 架构设计决策 (4) 第三方服务选型 (5) 技术栈升级评估
---

# 技术选型决策技能

本技能提供项目的技术选型决策支持，帮助用户在技术选择中做出明智决策。

## 触发条件

当用户说以下内容时，应该使用此技能：
- "应该用 xxx 还是 yyy"
- "选择哪个 xxx 框架/库"
- "对比 xxx 和 yyy"
- "推荐一个 xxx 方案"
- "要不要升级到 xxx"
- "要不要引入 xxx"
- "技术选型建议"

## 核心规范

### 规范1：本项目技术栈

#### 后端技术栈

| 层级 | 技术 | 版本 | 说明 |
|------|------|------|------|
| **编程语言** | Go | 1.24+ | 高性能、并发友好 |
| **微服务框架** | Kratos | 2.x | bilibili 开源微服务框架 |
| **API 定义** | Protobuf | 3.x | 接口定义与数据序列化 |
| **RPC 通信** | gRPC | 1.x | 高性能 RPC 框架 |
| **ORM 框架** | GORM | 2.x | Go 主流 ORM |
| **数据库** | PostgreSQL | 14+ | 主数据库（推荐） |
| **数据库** | MySQL | 8.0+ | 兼容支持 |
| **缓存** | Redis (Rueidis) | 6.0+ | 高性能 Redis 客户端 |
| **任务队列** | Asynq | 0.24+ | 基于 Redis 的任务队列 |
| **依赖注入** | Wire | 0.6+ | Google 编译时依赖注入 |
| **可观测性** | OpenTelemetry | 1.x | 链路追踪、指标、日志 |
| **AI 集成** | Eino | latest | CloudWeGo AI 框架 |
| **微信开发** | PowerWeChat | 3.x | 企业微信/公众号/小程序 SDK |

**选择 Kratos 的理由：**
- 生产级微服务框架，bilibili 内部大规模使用
- 完善的工具链（kratos-cli、protoc 插件）
- 内置 gRPC + HTTP 双协议支持
- 优秀的中间件生态
- 强大的配置管理和服务发现

#### 前端技术栈

| 层级 | 技术 | 版本 | 说明 |
|------|------|------|------|
| **编程语言** | TypeScript | 5.x | 类型安全 |
| **前端框架** | Vue | 3.x | 渐进式框架 |
| **构建工具** | Vite | 5.x | 现代化构建工具 |
| **UI 组件库** | Ant Design Vue | 4.x | 企业级组件库 |
| **状态管理** | Pinia | 2.x | Vue 3 推荐状态管理 |
| **路由管理** | Vue Router | 4.x | Vue 官方路由 |
| **包管理器** | pnpm | 9.x | 高效的包管理（Monorepo） |
| **构建系统** | Turbo | 2.x | Monorepo 构建系统 |
| **HTTP 客户端** | Axios | 1.x | Promise HTTP 客户端 |
| **代码规范** | ESLint + Prettier | - | 代码质量保证 |

**选择 Vue 3 + Ant Design Vue 的理由：**
- Vue 3 学习曲线平缓，团队上手快
- Composition API 提供更好的代码组织
- Ant Design Vue 4 组件丰富、文档完善
- 中文社区活跃，问题容易解决

#### 基础设施

| 类型 | 技术 | 说明 |
|------|------|------|
| **容器化** | Docker | 容器运行环境 |
| **编排** | Kubernetes / Docker Compose | 容器编排 |
| **CI/CD** | GitHub Actions | 持续集成 |
| **版本控制** | Git | 代码管理 |
| **API 文档** | OpenAPI/Swagger | API 文档生成 |
| **代码生成** | Protoc + 自定义模板 | 自动化代码生成 |

### 规范2：技术选型评估维度

在做技术选型时，按以下维度进行评估（权重从高到低）：

| 维度 | 权重 | 考虑因素 |
|------|------|---------|
| **项目匹配度** | ⭐⭐⭐⭐⭐ | 是否解决实际问题，是否符合项目架构 |
| **团队熟悉度** | ⭐⭐⭐⭐⭐ | 学习成本、上手难度、团队技能储备 |
| **生态成熟度** | ⭐⭐⭐⭐ | 社区活跃度、文档质量、问题解答 |
| **性能表现** | ⭐⭐⭐⭐ | 是否满足性能需求、性能瓶颈 |
| **可维护性** | ⭐⭐⭐⭐ | 代码清晰度、调试便利性、长期维护成本 |
| **扩展性** | ⭐⭐⭐ | 是否便于扩展、插件生态 |
| **成本** | ⭐⭐⭐ | 开发成本、运维成本、License 费用 |
| **技术趋势** | ⭐⭐ | 是否是主流方向、长期支持 |

### 规范3：常见技术对比

#### Go Web 框架对比

| 框架 | 特点 | 适用场景 | 本项目评分 |
|------|------|---------|-----------|
| **Kratos** | 微服务、gRPC、工具链完善 | 企业级微服务 | ⭐⭐⭐⭐⭐ (当前选择) |
| Gin | 轻量、性能高、简单 | 单体 API 服务 | ⭐⭐⭐ |
| GoZero | 微服务、工具链、云原生 | 微服务系统 | ⭐⭐⭐⭐ |
| Fiber | 类似 Express、高性能 | 快速开发 API | ⭐⭐ |
| Echo | 高性能、中间件丰富 | Web 应用 | ⭐⭐⭐ |

**本项目选择 Kratos 的理由：**
- 原生支持 gRPC + HTTP 双协议（前后端通信用 HTTP，服务间用 gRPC）
- Protobuf 驱动开发，接口定义即文档
- Wire 依赖注入，代码结构清晰
- 工具链强大（代码生成、脚手架）
- bilibili 生产验证，稳定可靠

#### ORM 框架对比

| 框架 | 特点 | 适用场景 | 本项目评分 |
|------|------|---------|-----------|
| **GORM** | 功能完善、社区最大、易用 | 通用 ORM | ⭐⭐⭐⭐⭐ (当前选择) |
| XORM | 轻量、简单 | 小型项目 | ⭐⭐⭐ |
| ENT | Facebook 出品、类型安全、代码生成 | 大型项目 | ⭐⭐⭐⭐ |
| SQLBoiler | 代码生成、性能高 | 性能敏感场景 | ⭐⭐⭐ |
| SQL Builder | 手写 SQL、灵活 | 复杂 SQL | ⭐⭐ |

**本项目选择 GORM 的理由：**
- 功能最完善（关联、预加载、事务、钩子）
- 社区最活跃，问题容易解决
- 支持 PostgreSQL、MySQL 双数据库
- 代码生成工具成熟（GORM Gen）
- 学习成本低

#### 数据库选择

| 数据库 | 特点 | 适用场景 | 本项目评分 |
|--------|------|---------|-----------|
| **PostgreSQL** | 功能强大、ACID、扩展性好 | 复杂业务、大数据量 | ⭐⭐⭐⭐⭐ (推荐) |
| MySQL | 成熟稳定、简单 | 通用业务 | ⭐⭐⭐⭐ (兼容) |
| MongoDB | 文档型、灵活 | 非结构化数据 | ⭐⭐ |
| TiDB | 分布式、MySQL 兼容 | 超大规模 | ⭐⭐⭐ |

**本项目推荐 PostgreSQL 的理由：**
- JSONB 支持（适合存储配置、元数据）
- 强大的全文搜索（中文分词）
- 地理位置查询（PostGIS）
- 高级功能（CTE、Window Functions、数组类型）
- 并发性能优于 MySQL

#### Redis 客户端对比

| 客户端 | 特点 | 适用场景 | 本项目评分 |
|--------|------|---------|-----------|
| **Rueidis** | 高性能、自动 Pipeline、Server-side Caching | 高并发、低延迟 | ⭐⭐⭐⭐⭐ (当前选择) |
| go-redis | 功能完善、社区大 | 通用场景 | ⭐⭐⭐⭐ |
| redigo | 老牌、稳定 | 传统项目 | ⭐⭐⭐ |

**本项目选择 Rueidis 的理由：**
- 自动 Pipeline，性能提升显著
- Server-side Caching（Redis 6.0+）
- 类型安全的命令 API
- 支持 Redis Cluster、Sentinel

#### 任务队列对比

| 方案 | 特点 | 适用场景 | 本项目评分 |
|------|------|---------|-----------|
| **Asynq** | 基于 Redis、可靠、Web UI | 通用异步任务 | ⭐⭐⭐⭐⭐ (当前选择) |
| Machinery | 功能丰富、支持多 Broker | 复杂工作流 | ⭐⭐⭐⭐ |
| RabbitMQ | 企业级消息队列 | 大规模消息 | ⭐⭐⭐ |
| Kafka | 高吞吐、日志流 | 大数据流处理 | ⭐⭐ |

**本项目选择 Asynq 的理由：**
- 基于 Redis，无需额外中间件
- 支持任务重试、优先级、定时任务
- 提供 Web UI 监控面板
- 代码简洁，易于集成

#### 前端 UI 组件库对比

| 组件库 | 特点 | 适用场景 | 本项目评分 |
|--------|------|---------|-----------|
| **Ant Design Vue** | 企业级、组件丰富、中文友好 | 中后台系统 | ⭐⭐⭐⭐⭐ (当前选择) |
| Element Plus | 简洁、轻量、上手快 | 中小型后台 | ⭐⭐⭐⭐ |
| Naive UI | 现代、TypeScript | 新项目 | ⭐⭐⭐ |
| Vuetify | Material Design | 移动优先 | ⭐⭐ |
| Quasar | 全平台、功能强 | 跨端应用 | ⭐⭐⭐ |

**本项目选择 Ant Design Vue 的理由：**
- 组件最丰富（Table、Form、Tree 等企业级组件）
- 中文文档最完善
- Ant Design 设计体系成熟
- 社区活跃，生态完善（ProComponents）

### 规范4：技术选型决策流程

当面临技术选型时，按以下流程进行：

#### 第 1 步：明确需求

**询问用户：**
1. 要解决什么问题？
2. 有哪些功能需求？
3. 有哪些非功能需求（性能、可用性、扩展性）？
4. 团队技能储备如何？
5. 有无时间/成本限制？

#### 第 2 步：调研候选方案

**自动执行：**
1. 列出 2-3 个候选方案
2. 查阅官方文档和社区评价
3. 查看 GitHub Star、活跃度、Issue 数量
4. 分析技术栈兼容性

#### 第 3 步：对比分析

使用以下模板进行对比：

```markdown
## 候选方案对比

### 方案 A：[技术名称]
- **优点：**
  - 优点 1
  - 优点 2
  - 优点 3
- **缺点：**
  - 缺点 1
  - 缺点 2
- **学习成本：** 低/中/高
- **社区活跃度：** ⭐⭐⭐⭐⭐
- **与本项目匹配度：** ⭐⭐⭐⭐

### 方案 B：[技术名称]
...

## 对比矩阵

| 维度 | 方案 A | 方案 B | 方案 C |
|------|--------|--------|--------|
| 项目匹配度 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| 团队熟悉度 | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ |
| 生态成熟度 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| 性能表现 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| 可维护性 | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| **总分** | **21** | **19** | **15** |
```

#### 第 4 步：推荐方案

**提供建议：**
1. 明确推荐的方案
2. 说明推荐理由（结合评估维度）
3. 指出潜在风险
4. 提供备选方案

#### 第 5 步：POC 验证（可选）

**如果用户犹豫，建议：**
1. 小范围 POC（Proof of Concept）
2. 在非核心模块试点
3. 验证关键功能和性能指标
4. 根据验证结果决策

#### 第 6 步：文档记录

**生成决策文档：**

```markdown
# 技术选型决策文档

## 决策背景
描述为什么需要做这个技术选型。

## 需求分析
- **功能需求：** xxx
- **性能需求：** xxx
- **扩展需求：** xxx
- **团队技能：** xxx
- **时间成本：** xxx

## 候选方案
### 方案 A：xxx
- **优点：** ...
- **缺点：** ...
- **成本：** ...

### 方案 B：xxx
- **优点：** ...
- **缺点：** ...
- **成本：** ...

## 对比分析
| 维度 | 方案 A | 方案 B |
|------|--------|--------|
| 项目匹配度 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| 团队熟悉度 | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| 生态成熟度 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| 性能表现 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 可维护性 | ⭐⭐⭐⭐ | ⭐⭐⭐ |

## 最终决策
**选择方案：** 方案 A

**理由：**
1. 理由 1
2. 理由 2
3. 理由 3

## 风险与应对
- **风险1：** xxx
  - **应对措施：** xxx
- **风险2：** xxx
  - **应对措施：** xxx

## 实施计划
1. 第 1 步：xxx
2. 第 2 步：xxx
3. 第 3 步：xxx

## 决策日期
YYYY-MM-DD

## 决策人
@username
```

保存到：`doc/tech-decisions/YYYY-MM-DD-[主题].md`

### 规范5：新技术引入原则

在 ai-boilerplate 项目中引入新技术时，必须遵循以下原则：

#### 1. 解决实际问题
- ❌ 不为了新而新，不追逐技术热点
- ✅ 必须解决现有痛点或提升开发效率
- ✅ 有明确的业务价值

#### 2. 与现有架构兼容
- ✅ 与 Kratos 框架无冲突
- ✅ 与 GORM、Protobuf、Wire 等核心技术兼容
- ✅ 不破坏现有代码结构

#### 3. 团队可接受
- ✅ 学习成本可控（1-2 周内上手）
- ✅ 有中文文档或教程
- ✅ 团队成员有相关经验或愿意学习

#### 4. 可回退
- ✅ 有备选方案
- ✅ 新技术失败时可快速切换
- ✅ 不锁定特定供应商

#### 5. 小范围试点
- ✅ 先在非核心模块验证
- ✅ 验证性能、稳定性、易用性
- ✅ 成功后再推广到核心模块

#### 6. 文档先行
- ✅ 记录选型理由
- ✅ 编写使用指南
- ✅ 记录最佳实践和避坑指南

### 规范6：技术债务管理

技术债务记录模板：

```markdown
# 技术债务清单

## 债务1：[简短描述]
- **产生原因：** 赶工期 / 需求变更 / 技术限制
- **影响范围：** xxx 模块
- **优先级：** 🔴 高 / 🟡 中 / 🟢 低
- **技术风险：** 性能问题 / 可维护性差 / 安全隐患
- **解决方案：** 具体方案描述
- **预计工时：** x 人天
- **计划时间：** YYYY-MM-DD

## 债务2：使用 Element Plus 而非 Ant Design Vue
- **产生原因：** 历史遗留
- **影响范围：** 前端 UI 层
- **优先级：** 🟡 中
- **技术风险：** 组件库不统一，维护成本高
- **解决方案：** 统一迁移到 Ant Design Vue
- **预计工时：** 5 人天
- **计划时间：** 2025-Q2

## 债务3：部分服务未使用 gRPC
- **产生原因：** 早期快速开发
- **影响范围：** 服务间通信
- **优先级：** 🟢 低
- **技术风险：** 无法享受 gRPC 性能优势
- **解决方案：** 逐步迁移到 gRPC
- **预计工时：** 10 人天
- **计划时间：** 2025-Q3
```

保存到：`doc/tech-debt.md`

### 规范7：常见技术选型场景

#### 场景1：选择 Go Web 框架
**问题：** "用 Gin 还是 Kratos？"

**决策流程：**
1. 项目规模：单体 → Gin，微服务 → Kratos
2. 性能需求：极致性能 → Gin，综合考虑 → Kratos
3. 团队经验：新手 → Gin，有微服务经验 → Kratos
4. 长期维护：小项目 → Gin，企业级 → Kratos

**本项目推荐：** Kratos（微服务架构、企业级项目）

#### 场景2：选择前端状态管理
**问题：** "Vuex 还是 Pinia？"

**决策流程：**
1. Vue 版本：Vue 2 → Vuex，Vue 3 → Pinia
2. TypeScript：弱类型 → Vuex，强类型 → Pinia
3. 开发体验：传统模式 → Vuex，Composition API → Pinia

**本项目推荐：** Pinia（Vue 3 官方推荐，TypeScript 友好）

#### 场景3：选择数据库
**问题：** "PostgreSQL 还是 MySQL？"

**决策流程：**
1. 复杂查询：多 → PostgreSQL，少 → MySQL
2. JSON 数据：多 → PostgreSQL，少 → MySQL
3. 团队经验：无 PG 经验 → MySQL，有经验 → PostgreSQL
4. 高级功能：需要 → PostgreSQL，不需要 → MySQL

**本项目推荐：** PostgreSQL（功能强大、适合复杂业务）

#### 场景4：选择缓存策略
**问题：** "什么时候用缓存？用什么缓存？"

**决策矩阵：**
| 场景 | 方案 | 理由 |
|------|------|------|
| 热点数据（如配置） | Redis | 高频访问，变化少 |
| 查询结果 | Redis（短 TTL） | 减少 DB 压力 |
| 会话数据 | Redis | 跨服务共享 |
| 计算结果 | 本地缓存 | 无需共享 |
| 防重放 | Redis（Set + TTL） | 分布式去重 |

#### 场景5：选择任务队列
**问题：** "Asynq 还是 RabbitMQ？"

**决策流程：**
1. 消息量：小/中 → Asynq，大 → RabbitMQ
2. 已有 Redis：是 → Asynq，否 → RabbitMQ
3. 复杂路由：需要 → RabbitMQ，不需要 → Asynq
4. 团队经验：熟悉 Redis → Asynq，熟悉 MQ → RabbitMQ

**本项目推荐：** Asynq（已有 Redis，无需额外中间件）

#### 场景6：选择日志方案
**问题：** "Zap 还是 Logrus？"

**决策流程：**
1. 性能需求：高 → Zap，中 → Logrus
2. 结构化日志：需要 → Zap/Logrus，不需要 → log
3. 生态集成：Kratos 推荐 → Zap

**本项目推荐：** Kratos 内置日志（基于 Zap）

#### 场景7：选择 AI 框架
**问题：** "直接调用 API 还是用 Eino？"

**决策流程：**
1. 简单场景（单次调用） → 直接调用 API
2. 复杂工作流（多步骤、分支） → Eino
3. 需要 Agent（记忆、工具） → Eino
4. 云厂商绑定 → CloudWeGo Eino

**本项目推荐：** Eino（复杂 AI 工作流、与字节跳动火山引擎集成）

## 常见问题

### Q1: 要不要升级到最新版本？

**评估标准：**
1. **新版本有什么改进？**
   - 性能提升 > 10% → 考虑升级
   - 重大 Bug 修复 → 尽快升级
   - 新功能是否需要 → 按需升级

2. **是否有破坏性变更？**
   - 无 → 放心升级
   - 小 → 评估改动成本
   - 大 → 延后升级或 POC 验证

3. **依赖是否兼容？**
   - 全部兼容 → 可以升级
   - 部分不兼容 → 评估风险
   - 核心依赖不兼容 → 暂不升级

4. **社区反馈如何？**
   - 稳定版 → 可以升级
   - 大量 Bug 反馈 → 等待修复
   - 刚发布 → 观察 1-2 个月

**决策建议：**
- 小版本升级（如 2.7.0 → 2.7.1）：评估后可升级
- 大版本升级（如 2.x → 3.x）：充分测试后升级
- 安全补丁：立即升级

### Q2: 要不要引入新框架/库？

**评估流程：**
1. **解决什么问题？**
   - 核心痛点 → 考虑引入
   - 边缘场景 → 暂不引入
   - 无实际痛点 → 不引入

2. **现有方案是否可行？**
   - 现有方案够用 → 不引入
   - 现有方案有缺陷 → 考虑引入
   - 无现有方案 → 可以引入

3. **团队学习成本？**
   - 1 天上手 → 可以引入
   - 1 周上手 → 评估收益
   - 1 个月上手 → 慎重考虑

4. **长期维护成本？**
   - 社区活跃 → 可以引入
   - 文档完善 → 可以引入
   - 小众库/停止维护 → 不引入

**决策模板：**
```markdown
## 是否引入 [技术名称]

### 背景
当前存在的问题：xxx

### 现有方案
- 方案1：xxx（缺点：xxx）
- 方案2：xxx（缺点：xxx）

### 新方案评估
- **优点：** xxx
- **缺点：** xxx
- **学习成本：** x 天
- **维护成本：** 低/中/高
- **社区活跃度：** ⭐⭐⭐⭐⭐

### 决策
□ 引入（理由：xxx）
□ 不引入（理由：xxx）
□ POC 验证后决定
```

### Q3: 技术选型有分歧怎么办？

**解决步骤：**

#### 1. 明确评估标准
- 列出关键评估维度（参考规范2）
- 对每个维度赋予权重
- 所有人认可评估标准

#### 2. 数据驱动决策
- 收集客观数据（性能测试、社区数据）
- 避免主观臆断
- 用数据说话

#### 3. 小范围 POC
- 各方案分别实现一个小功能
- 对比代码量、性能、开发体验
- 团队投票选择

#### 4. 时间盒决策
- 限定讨论时间（如 1 小时）
- 超时未达成共识 → 由技术负责人决策
- 避免无休止争论

#### 5. 记录决策过程
- 记录各方案的优缺点
- 记录选择理由
- 后续复盘时有据可查

### Q4: 如何避免过度设计？

**YAGNI 原则（You Aren't Gonna Need It）：**

❌ **不要做：**
- 为"可能的需求"预留扩展点
- 过早抽象（3 次重复前不抽象）
- 引入复杂的设计模式（如果简单方案够用）
- 为"可能的性能问题"过早优化

✅ **应该做：**
- 只实现当前确定的需求
- 保持代码简单直接
- 有需求时再重构
- 性能问题出现后再优化

**判断标准：**
- 如果删除这段代码，当前功能是否受影响？
  - 不受影响 → 过度设计，删除
  - 受影响 → 合理设计，保留

### Q5: 如何处理技术债务？

**处理策略：**

#### 1. 识别技术债务
- 代码审查时记录
- 开发过程中记录
- 定期 Code Review 发现

#### 2. 评估优先级
- 🔴 高优先级：影响稳定性、安全性、性能
- 🟡 中优先级：影响开发效率、可维护性
- 🟢 低优先级：代码不够优雅、不够完美

#### 3. 制定还债计划
- 每个迭代分配 20% 时间还债
- 高优先级债务立即处理
- 低优先级债务在重构时顺带处理

#### 4. 预防新债务
- 代码审查把关
- 制定编码规范
- 自动化检测（Linter、CI）

### Q6: 如何评估开源项目质量？

**评估清单：**

```markdown
## 开源项目评估清单

### 基本信息
- [ ] GitHub Star 数量（> 1000）
- [ ] 最近更新时间（< 6 个月）
- [ ] License（MIT/Apache 2.0 等宽松协议）
- [ ] 维护者（个人 / 团队 / 公司）

### 文档质量
- [ ] README 是否完整
- [ ] 是否有中文文档
- [ ] 是否有 API 文档
- [ ] 是否有示例代码
- [ ] 是否有最佳实践

### 社区活跃度
- [ ] Issue 响应速度（< 1 周）
- [ ] PR 合并频率（每月有合并）
- [ ] Contributor 数量（> 10）
- [ ] 讨论区活跃度

### 代码质量
- [ ] 是否有单元测试（覆盖率 > 80%）
- [ ] 是否有 CI/CD
- [ ] 代码风格是否统一
- [ ] 是否有代码审查流程

### 生态
- [ ] 是否有配套工具
- [ ] 是否有社区教程
- [ ] 是否有第三方插件
- [ ] 是否被知名项目使用

### 风险
- [ ] 是否依赖过多
- [ ] 是否有安全漏洞
- [ ] 是否有停止维护风险
- [ ] 是否有重大 Breaking Change

### 评分
- 优秀（✅ 12+ 项）：推荐使用
- 良好（✅ 8-11 项）：可以使用
- 一般（✅ 4-7 项）：慎重考虑
- 较差（✅ 0-3 项）：不推荐
```

### Q7: 如何做技术预研？

**预研流程：**

#### 第 1 步：确定预研目标
- 要解决什么问题？
- 预期达到什么效果？
- 预研时间限制？

#### 第 2 步：文档调研
- 阅读官方文档
- 查看社区教程
- 分析成功案例

#### 第 3 步：Demo 开发
- 搭建最小可用 Demo
- 验证核心功能
- 测试性能指标

#### 第 4 步：问题记录
- 遇到的坑
- 解决方案
- 最佳实践

#### 第 5 步：输出报告
```markdown
# [技术名称] 预研报告

## 预研目标
xxx

## 技术方案
xxx

## Demo 实现
xxx

## 性能测试
- QPS：xxx
- 延迟：xxx
- 资源占用：xxx

## 优缺点分析
### 优点
- 优点1
- 优点2

### 缺点
- 缺点1
- 缺点2

## 问题记录
### 问题1：xxx
- **描述：** xxx
- **解决方案：** xxx

## 结论
□ 推荐使用（理由：xxx）
□ 不推荐使用（理由：xxx）
□ 需要进一步验证（xxx）

## 下一步计划
1. xxx
2. xxx
```

保存到：`doc/research/YYYY-MM-DD-[主题].md`

---

## 技能执行策略

### 1. 充分理解需求
- 先询问用户具体场景
- 了解选型背景和约束
- 明确评估标准

### 2. 数据驱动决策
- 查阅官方文档和社区数据
- 提供客观对比（Star 数、性能数据）
- 避免主观臆断

### 3. 提供多个方案
- 至少提供 2-3 个候选方案
- 明确说明推荐方案及理由
- 指出各方案的优缺点和适用场景

### 4. 考虑项目实际
- 结合 ai-boilerplate 的技术栈
- 考虑团队技能储备
- 评估引入成本和收益

### 5. 输出决策文档
- 记录选型过程和理由
- 保存到 `doc/tech-decisions/` 目录
- 便于后续回顾和复盘

---

## 与其他技能的协作

### backend-database 技能
- **关系：** 数据库选型后，使用 backend-database 设计表结构
- **协作：** tech-decision 选择 PostgreSQL/MySQL → backend-database 设计表

### backend-crud 技能
- **关系：** ORM 框架选型后，使用 backend-crud 生成代码
- **协作：** tech-decision 选择 GORM → backend-crud 生成 CRUD 代码

### interview 技能
- **关系：** 架构设计时可能涉及技术选型（互补关系，非冲突）
- **定位差异：**
  - interview：战略层 - 探索"做什么、怎么做"（概念设计）
  - tech-decision：战术层 - 决策"用什么技术"（具体选型）
- **协作顺序：**
  1. interview：探索架构方案和实现思路（高层设计）
  2. tech-decision：选择具体技术框架和工具（细节决策）
- **协作示例：**
  - 场景：开发实时通知系统
  - interview 输出：设计 WebSocket 架构、消息流程、错误处理机制
  - tech-decision 输出：选择 gorilla/websocket 库 + Redis Stream 消息队列
- **决策树：**
  - 问题是"如何实现？" → 使用 interview
  - 问题是"选哪个技术？" → 使用 tech-decision
  - 复杂场景 → 先 interview（战略）再 tech-decision（战术）

---

## 快速参考

### 技术选型流程
1. 明确需求（功能、性能、团队、成本）
2. 调研候选方案（2-3 个）
3. 对比分析（使用评估维度）
4. 推荐方案（说明理由）
5. POC 验证（如需要）
6. 文档记录（保存决策文档）

### 评估维度权重
1. 项目匹配度 ⭐⭐⭐⭐⭐
2. 团队熟悉度 ⭐⭐⭐⭐⭐
3. 生态成熟度 ⭐⭐⭐⭐
4. 性能表现 ⭐⭐⭐⭐
5. 可维护性 ⭐⭐⭐⭐
6. 扩展性 ⭐⭐⭐
7. 成本 ⭐⭐⭐
8. 技术趋势 ⭐⭐

### 新技术引入原则
1. ✅ 解决实际问题
2. ✅ 与现有架构兼容
3. ✅ 团队可接受
4. ✅ 可回退
5. ✅ 小范围试点
6. ✅ 文档先行

### 常见选型场景快速决策

| 场景 | 推荐方案 | 理由 |
|------|----------|------|
| Web 框架 | Kratos | 微服务、企业级 |
| ORM | GORM | 功能完善、社区大 |
| 数据库 | PostgreSQL | 功能强大、适合复杂业务 |
| 缓存 | Redis (Rueidis) | 高性能、自动 Pipeline |
| 任务队列 | Asynq | 基于 Redis、简单易用 |
| 前端框架 | Vue 3 | 学习曲线平缓 |
| UI 组件库 | Ant Design Vue | 企业级、中文友好 |
| 状态管理 | Pinia | Vue 3 官方推荐 |
| 包管理器 | pnpm | Monorepo、节省空间 |
| 构建工具 | Vite | 快速、现代化 |

---

## 示例：完整的技术选型过程

### 用户提问："我要开发一个实时聊天功能，应该用什么技术？"

#### 第 1 步：明确需求
**询问用户：**
- 预计多少用户同时在线？（性能需求）
- 是否需要消息持久化？（功能需求）
- 是否需要群聊？（功能需求）
- 是否需要离线消息推送？（功能需求）

**假设回答：**
- 同时在线：1000 人
- 需要持久化：是
- 需要群聊：是
- 离线推送：需要

#### 第 2 步：调研候选方案

**方案 A：WebSocket + Redis Pub/Sub**
- 优点：简单、实时性好、无需额外中间件
- 缺点：消息不持久化、扩展性有限
- 适用场景：小规模、无持久化需求

**方案 B：WebSocket + Kafka**
- 优点：高吞吐、消息持久化、可扩展
- 缺点：重量级、运维复杂、学习成本高
- 适用场景：大规模、高可靠性

**方案 C：WebSocket + Redis Stream + PostgreSQL**
- 优点：消息持久化、扩展性好、运维简单
- 缺点：需要 Redis 6.0+
- 适用场景：中小规模、需持久化

#### 第 3 步：对比分析

| 维度 | Redis Pub/Sub | Kafka | Redis Stream + PG |
|------|---------------|-------|-------------------|
| 项目匹配度 | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 团队熟悉度 | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ |
| 生态成熟度 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| 性能表现 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| 可维护性 | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ |
| **总分** | **19** | **17** | **21** |

#### 第 4 步：推荐方案

**推荐方案：WebSocket + Redis Stream + PostgreSQL**

**理由：**
1. 满足 1000 人在线需求（性能足够）
2. Redis Stream 支持消息持久化和消费组
3. PostgreSQL 存储历史消息，支持复杂查询
4. 团队已熟悉 Redis 和 PostgreSQL，无需引入新中间件
5. 运维成本低，易于维护

**架构设计：**
```
用户 → WebSocket → Kratos 服务 → Redis Stream（实时消息）
                                  ↓
                           PostgreSQL（历史消息）
```

**实现要点：**
1. WebSocket 连接管理（在 Kratos 服务中）
2. Redis Stream 作为消息分发中心
3. PostgreSQL 存储历史消息（异步写入）
4. 离线推送集成 FCM/APNs

**风险与应对：**
- 风险1：Redis 单点故障
  - 应对：Redis 主从 + Sentinel
- 风险2：WebSocket 连接数限制
  - 应对：水平扩展多个 Kratos 实例

#### 第 5 步：输出决策文档

生成文档并保存到：
`doc/tech-decisions/2025-12-30-realtime-chat-solution.md`

---

## 总结

本技能提供了 ai-boilerplate 项目的技术选型决策支持，涵盖：
- ✅ 完整的技术栈清单
- ✅ 系统的评估维度和流程
- ✅ 常见技术方案对比
- ✅ 实用的决策模板
- ✅ 新技术引入原则
- ✅ 技术债务管理

使用本技能时，遵循"数据驱动、用户导向、文档记录"原则，帮助用户做出明智的技术决策。
